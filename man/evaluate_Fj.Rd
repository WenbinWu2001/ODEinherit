% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/evaluate_Fj.R
\name{evaluate_Fj}
\alias{evaluate_Fj}
\title{Evaluate \eqn{F_j} and Recovery the Trajectory for a Single Variable}
\usage{
evaluate_Fj(
  bj,
  cj,
  interaction_term,
  kernel,
  kernel_params,
  kk_array = NULL,
  obs_time,
  theta_j,
  tt,
  Yj,
  yy_smth
)
}
\arguments{
\item{bj}{A numeric scalar, giving the estimated \eqn{b_j} from Kernel ODE
(i.e., \code{res_bj[j]}).}

\item{cj}{A numeric vector of length \code{n}, giving the estimated \eqn{c_j} from
Kernel ODE (i.e., \code{res_cj[,j]}).}

\item{interaction_term}{A logical value specifying whether to include interaction effects in the model.}

\item{kernel}{Kernel function to use.}

\item{kernel_params}{A list of length \code{p}, where each element is a named list of
parameters for a specific variable (e.g., \code{list(bandwidth = 1)} for Gaussian kernel). If the
list has length 1, the same parameter set is used for all variables. This is typically the output of \code{\link[=auto_select_kernel_params]{auto_select_kernel_params()}}.}

\item{kk_array}{Optional precomputed kernel array on \code{tt}. An array of
dimension (\code{len}, \code{len}, \code{p}) when \code{interaction_term = FALSE}, or (\code{len},
\code{len}, \code{p^2}) when \code{interaction_term = TRUE}, where \code{len = length(tt)}.
Providing \code{kk_array} enables reuse across variables and can greatly reduce
computation.}

\item{obs_time}{A numeric vector of length \code{n} representing observation time points.}

\item{theta_j}{A numeric vector of length \code{p} (if \code{interaction = FALSE}) or
\code{p^2} (if \code{interaction = TRUE}), giving the estimated \eqn{\theta_j}
coefficients for variable \eqn{j} from Kernel ODE (i.e., \code{res_theta[,j]}).}

\item{tt}{A numeric vector representing a finer time grid used for evaluating the smoothed trajectories and their derivatives.}

\item{Yj}{A numeric vector of length \code{n}, giving the observed trajectory for variable
\eqn{j} (i.e., \code{Y[, j]}).}

\item{yy_smth}{Numeric matrix of dimension (\code{len}, \code{p}); smoothed
trajectories evaluated on \code{tt} (i.e., output of \code{kernelODE_step1()}).}
}
\value{
A list with components:
\describe{
\item{\code{theta_j0}}{A numeric scalar giving estimated initial condition for variable \eqn{j}.}
\item{\code{Fj_est}}{A numeric vector (length \code{len}) giving the evaluated \eqn{F_j} on \code{tt}.}
\item{\code{yy_est}}{A numeric vector (length \code{len}) giving the recovered trajectory on \code{tt}.}
\item{\code{TV_est}}{A numeric scalar giving the total variation \eqn{\int |F_j(t)| \, dt}
approximated on \code{tt}.}
}
}
\description{
Evaluates the derivative function \eqn{F_j} of a single variable on the
integration grid \code{tt} and recovers the trajectory by numerical integration,
given estimates of \eqn{b_j}, \eqn{c_j}, and \eqn{\theta_j}.
}
\details{
Given \eqn{b_j}, \eqn{c_j}, and \eqn{\theta_j}, the function
constructs the kernel-weighted integral operator on the grid \code{tt} to evaluate
\eqn{F_j}, estimates the initial condition \eqn{\theta_{j0}}, then recovers
the trajectory via cumulative summation on \code{tt} (first-order approximation).
When provided, \code{kk_array} is reused to avoid recomputing kernel blocks.
}
\seealso{
\code{\link[=kernelODE_step1]{kernelODE_step1()}}, \code{\link[=kernelODE_step2]{kernelODE_step2()}}, \code{\link[=assess_recov_traj]{assess_recov_traj()}}
}
