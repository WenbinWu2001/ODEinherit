% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/evaluate_Fj.R
\name{evaluate_Fj}
\alias{evaluate_Fj}
\title{Evaluate \eqn{F_j} and Recovery the Trajectory for a Single Variable}
\usage{
evaluate_Fj(
  bj,
  cj,
  interaction_term,
  kernel,
  kernel_params,
  kk_array = NULL,
  obs_time,
  theta_j,
  tt,
  Yj,
  yy_smth
)
}
\arguments{
\item{bj}{A numeric scalar, giving the estimated \eqn{b_j} from Kernel ODE
(i.e., \code{res_bj[j]}).}

\item{cj}{A numeric vector of length \code{n}, giving the estimated \eqn{c_j} from
Kernel ODE (i.e., \code{res_cj[,j]}).}

\item{interaction_term}{A logical value specifying whether to include
interaction effects in the model.}

\item{kernel}{Kernel function to use.}

\item{kernel_params}{A list of length \code{p}, where each element is a named list
of parameters for a specific variable (e.g., \code{list(bandwidth = 1)} for
Gaussian kernel). If the list has length 1, the same parameter set is used
for all variables. This is typically the output of
\code{\link[=auto_select_kernel_params]{auto_select_kernel_params()}}.}

\item{kk_array}{Optional precomputed kernel array on \code{tt}. An array of
dimension (\code{len}, \code{len}, \code{p}) when \code{interaction_term = FALSE}, or (\code{len},
\code{len}, \code{p^2}) when \code{interaction_term = TRUE}, where \code{len = length(tt)}.
Providing \code{kk_array} enables reuse across variables and can greatly reduce
computation.}

\item{obs_time}{A numeric vector of length \code{n} representing observation time points.}

\item{theta_j}{A numeric vector of length \code{p} (if \code{interaction = FALSE}) or
\code{p^2} (if \code{interaction = TRUE}), giving the estimated \eqn{\theta_j}
coefficients for variable \eqn{j} from Kernel ODE (i.e., \code{res_theta[,j]}).}

\item{tt}{A numeric vector representing a finer time grid used for evaluating the smoothed trajectories and their derivatives.}

\item{Yj}{A numeric vector of length \code{n}, giving the observed trajectory for variable
\eqn{j} (i.e., \code{Y[, j]}).}

\item{yy_smth}{Numeric matrix of dimension (\code{len}, \code{p}); smoothed
trajectories evaluated on \code{tt} (i.e., output of \code{kernelODE_step1()}).}
}
\value{
A list with components:
\describe{
\item{\code{theta_j0}}{A numeric scalar giving estimated initial condition for variable \eqn{j}.}
\item{\code{Fj_est}}{A numeric vector (length \code{len}) giving the evaluated \eqn{F_j} on \code{tt}.}
\item{\code{yy_est}}{A numeric vector (length \code{len}) giving the recovered trajectory on \code{tt}.}
\item{\code{TV_est}}{A numeric scalar giving the total variation \eqn{\int |F_j(t)| \, dt}
approximated on \code{tt}.}
}
}
\description{
Evaluates the derivative function \eqn{F_j} of a single variable on the
integration grid \code{tt} and recovers the trajectory by numerical integration,
given estimates of \eqn{b_j}, \eqn{c_j}, and \eqn{\theta_j}.
}
\details{
Given \eqn{b_j}, \eqn{c_j}, and \eqn{\theta_j}, the function
constructs the kernel-weighted integral operator on the grid \code{tt} to evaluate
\eqn{F_j}, estimates the initial condition \eqn{\theta_{j0}}, then recovers
the trajectory via cumulative summation on \code{tt} (first-order approximation).
When provided, \code{kk_array} is reused to avoid recomputing kernel blocks.
}
\examples{
set.seed(1)
obs_time <- seq(0, 1, length.out = 10)
Y <- cbind(sin(2 * pi * obs_time), cos(4 * pi * obs_time)) + 0.1 * matrix(rnorm(20), 10, 2)  # each col is a variable
tt <- seq(0, 1, length.out = 100)
res_step1 <- kernelODE_step1(Y = Y, obs_time = obs_time, tt = tt)

kernel <- "gaussian"
kernel_params <- auto_select_kernel_params(kernel = kernel, Y = Y)
res_step2 <- kernelODE_step2(Y = Y, obs_time = obs_time, yy_smth = res_step1$yy_smth, tt = tt, kernel = kernel, kernel_params = kernel_params)

j <- 1  # evaluate Fj for the first variable
res_eval <- evaluate_Fj(bj = res_step2$res_bj[j],
                        cj = res_step2$res_cj[,j],
                        interaction_term = F,
                        kernel = kernel,
                        kernel_params = kernel_params,
                        obs_time = obs_time,
                        theta_j = res_step2$res_theta[,j],
                        tt = tt,
                        Yj = Y[,j],
                        yy_smth = res_step1$yy_smth)
yy_j_est <- res_eval$yy_est

# plot the evaluated traj
plot(NA, type = "n",
     xlab = "Time index", ylab = "Value",
     xlim = c(0,1), ylim = range(c(yy_j_est, Y[,j]), na.rm = T))
lines(obs_time, Y[,j], lty = 1)
lines(tt, yy_j_est, lty = 2)
legend("topright",
       legend = c("obs.", "eval."),
       lty = c(1,2),
       col = "black")

}
\seealso{
\code{\link[=kernelODE_step1]{kernelODE_step1()}}, \code{\link[=kernelODE_step2]{kernelODE_step2()}}, \code{\link[=assess_recov_traj]{assess_recov_traj()}}
}
