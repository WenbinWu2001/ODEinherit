% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/kernelODE_step1.R
\name{kernelODE_step1}
\alias{kernelODE_step1}
\title{Smoothing Spline Estimates (Step 1 of Kernel ODE)}
\usage{
kernelODE_step1(Y, obs_time, tt)
}
\arguments{
\item{Y}{A numeric matrix of dimension (\code{n}, \code{p}), where each column corresponds to the observed trajectory of a variable. Rows align with \code{obs_time}.}

\item{obs_time}{A numeric vector of length \code{n} representing observation time points.}

\item{tt}{A numeric vector representing a finer time grid used for evaluating the smoothed trajectories and their derivatives.}
}
\value{
A list with components:
\describe{
\item{\code{yy_smth}}{A numeric matrix of dimension (\code{length(tt)}, \code{p}), where each column contains the smoothed trajectory of a variable evaluated on \code{tt}.}
\item{\code{init_vals_smth}}{A numeric vector of length \code{p} containing the estimated initial values (at time 0) for each variable.}
\item{\code{deriv_smth}}{A numeric matrix of dimension (\code{length(tt)}, \code{p}), where each column contains the smoothed first order derivative of a variable evaluated on \code{tt}.}
}
}
\description{
Computes smoothed trajectories and their derivatives using cubic smoothing splines.
This function serves as Step 1 in the Kernel ODE pipeline.
}
\examples{
# Example usage:
set.seed(1)
obs_time <- seq(0, 1, length.out = 10)
Y <- cbind(sin(2 * pi * obs_time), cos(4 * pi * obs_time)) + 0.1 * matrix(rnorm(20), 10, 2)  # each col is a variable
tt <- seq(0, 1, length.out = 100)
result <- smoother_SS(obs_time, Y, tt)
matplot(tt, result$yy_smth, type = "l", lty = 1, col = 1:2)
}
\references{
Original implementation adapted from \url{https://github.com/ChenShizhe/GRADE}
}
